#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <time.h>

const int LINE_SIZE = 1024;

typedef struct Person {
    int  age;
    double ga_ctg;
    double ga_b;
    char sex;
    double weight;
    double a1;
    double a5;

} Person;

typedef struct dados {
  double sum1;
  double me1;
  double largest1;
  double lowest1;
  double variance1;
  double median1;
  double q1_1;
  double q3_1;
} dados;


char* getfield(char* line, int num)
{
    char* tok;
    for (tok = strtok(line, ";"); tok && *tok; tok = strtok(NULL, ";\n")){
        if (!--num)
            return tok;
    }
    return NULL;
}

//double Sum_Elements (double array[] , int n);
float Find_median(double array[] , int n);
int Find_1Quartile(double array[] , int n);
int Find_3Quartile(double array[] , int n);
void how_soon_is_now ();

int main(){
    FILE* file = fopen("2.CSV", "r");
    char line[LINE_SIZE];

    Person* people;
    int count = 0;

    if (file == NULL) {
        perror("Error opening file");
        return -1;
    }

    //Count the number of columns to know how to allocate properly URGENT!!!
    char ch;
    int column_Number = 0;
    int line_Number = 0;

    while((ch=fgetc(file))!=EOF) {
        if(ch==';'){
            column_Number++;
            line_Number++;
        }
        if (ch == '\n')
            break;
    }
    printf("Number of columns: %d \n\n", column_Number + 1); //Plus one because the number of ; is -1 number of columns

    //

    while (fgets(line, LINE_SIZE, file)){count++;} // counts the number of lines in file

    // decreases count by one (since it will ignore first line of data)
    count--;

    if(count < 1) // no data
        return 0;

    // allocate memory for the age array
    people = (Person*)malloc(count * sizeof(Person));

    if (people == NULL) {
        perror("error allocating people array");
        exit(0);
    }

    rewind(file); // rewinds file

    fgets(line, LINE_SIZE, file); // reads first line (column names) and do nothing

    count = 0; // reset count to use it as array index
    while (fgets(line, LINE_SIZE, file))
    {
        char temp[LINE_SIZE];
        // Get every column of row as char*
        char* age = getfield(strcpy(temp, line), 1);
        char* ga_ctg = getfield(strcpy(temp, line), 2);
        char* ga_b = getfield(strcpy(temp, line), 3);
        char* sex = getfield(strcpy(temp, line), 4);
        char* weight = getfield(strcpy(temp, line), 5);
        char* a1 = getfield(strcpy(temp, line), 6);
        char* a5 = getfield(strcpy(temp, line), 7);
        // stores converted values in the person array
        people[count].age = atoi(age);
        people[count].ga_ctg = atof(ga_ctg);
        people[count].ga_b = atof(ga_b);
        people[count].sex = sex[0];
        people[count].weight = atof(weight);
        people[count].a1 = atof(a1);
        people[count].a5 = atof(a5);
        // -------------------------------------------

        count++;
    }

    // debugs array
    for (int i = 0; i < count; i++) {
        printf("age: %d | ga_ctg: %.2f | ga_b: %.2f | sex: %c | weight: %.2f | a1: %.2f | a5: %.2f\n",
               people[i].age, people[i].ga_ctg, people[i].ga_b, people[i].sex,
               people[i].weight, people[i].a1, people[i].a5);
    }

    //Sum all the elements inside the a1 array
    
    int j = 0;
    double sum = 0;
    for (j = 0; j < count; ++j){
        //The number of elements inside the array will be equal the number of lines - the title of the table

        sum += people[j].a1;
    }
    printf("\nThe sum of the elements in a1 is: %.2f\n", sum);


    //sum = Sum_Elements(&people->a1, count);

    //for (int k = 0; k < count; k++){
    //printf("\n%.2f\n", people[k].a1);
//}

    //          
   
   struct dados s1 = {.sum1 = sum};

    printf("\nIn dados struct: %.2f\n", s1.sum1);

   // printf("\nThe sum of the elements in a1 is: %.2f\n", sum);

    //Do the arithmetic average of the elements from the array a1

    float me = 0;

    me = (float) sum/ count;

    printf("\nThe arithmetic average in a1 is %.4f\n",me);

    struct dados s4 = {.me1 = me};
    printf("\nIn dados struct: %.2f\n", s4.me1);

    //

    //Find the greater value inside the a1 array
   double largest = people[0].a1;
   int position = 0;
   int loop;

   for (loop = 0; loop < count; loop++){
       if (people[loop].a1 > largest){
           largest = people[loop].a1 ;
           position = loop;
       }
   }
   printf("\nThe greater elements in the array a1 is: %.2f", largest);
   printf("\nIndex position of the greater element in a1 = %d \n", position);

    struct dados s2 = {.largest1 = largest};
    printf("\nIn dados struct: %.2f\n", s2.largest1);

      //Find the lowest value inside the array a1

    int position1 = 0;
    double lowest = people[0].a1;
    int loo;

    for (loo = 0; loo < count; loo++){
        if (people[loo].a1 < lowest){
            lowest = people[loo].a1;
            position1 = loo;
        }
    }
    printf("\nThe lowest elements in a1 is: %.2f", lowest);
    printf("\nIndex position of the lowest element in a1 = %d\n", position1);

    struct dados s3 = {.lowest1 = lowest};
    printf("\nIn dados struct: %.2f\n", s3.lowest1);

        //Variance
     double sum1 = 0;
     double variance = 0;
       for (int p = 0; p < count; p++){
           sum1 += pow(((people[p].a1) - me), 2.0);
       }

    double count1 = 1.0;
    double count2 = count - count1;

     variance = sqrt ((double) sum1 / (double) count2);
       printf("\nVariance in a1 would it be: %.2f?\n", variance);

      struct dados s5 = {.variance1 = variance};
    printf("\nIn dados struct: %.2f\n", s5.variance1);

        //Median

    float median = 0;

      median = Find_median(&people->a1, count);

        printf("\nThe median in a1 is: %.2f\n", median);

    struct dados s6 = {.me1 = me};
    printf("\nIn dados struct: %.2f\n", s6.me1);

      //1º Quartile

    int q1 = Find_1Quartile(&people->a1, count);;

    printf ("Q1 in a1 is: %.2f\n", people[q1].a1);

    struct dados s7 = {.q1_1 = people[q1].a1};
    printf("\nIn dados struct: %.2f\n", s7.q1_1);

      //3º Quartile

    int q3 = Find_3Quartile(&people->a1, count);

    printf ("Q3 in a1 is: %.2f\n", people[q3].a1);

    struct dados s8 = {.q3_1 = people[q3].a1};
    printf("\nIn dados struct: %.2f\n", s8.q3_1);

      //Time

      
    //how_soon_is_now ();

      //Send the results to a file

      /*FILE *outfile;

      outfile = fopen ("write.txt", "w+");

      if (outfile == NULL){
        fprintf(stderr, "\nError\n");
        exit (1);
      }

      //fwrite (&s3, sizeof(struct dados), 1, outfile);
      //fprintf (outfile, "Test, cacete %d", count);
      fputs ()

      if(fwrite != 0)
        printf("contents to file written successfully!\n");
      else
        printf("Error writing file !\n");

    fclose (outfile);*/


    fclose(file);
    //free(people);

    return 0;
}



/*double Sum_Elements(double array[], int n){
    int j = 0;
    double sumF = 0; 
    for (j = 0; j < n; ++j){
        //The number of elements inside the array will be equal the number of lines - the title of the table
        sumF += array[j];
    }

    for (int k = 0; k < n; k++){
      printf("\nThe elements received by the function sum were: %.2f\n", array[k]);
    }
//printf("\n%.2f\n", sumF);
  return sumF;
}*/


float Find_median(double array[] , int n){
    float median = 0;
    
//Sort the elements of the array in ascending order:

int i = 0;
int j = 0;
int temp = 0;

for (i = 0; i < n; i++){
  for (j = i+1; j < n; j++) { 
       if(array[i] > array[j]) {    
               temp = array[i];    
               array[i] = array[j];    
               array[j] = temp;
    }     
  }     
}       

    // if number of elements are even
    if(n%2 == 0)
        median = (array[(n/2)] + array[(n/2)+1])/2.0; 
    // if number of elements are odd
    else
        median = array[n/2];
    
    return median;
}

int Find_1Quartile(double array[] , int n) {
    int quartile = 0;

//Sort the elements of the array in ascending order:

int i = 0;
int j = 0;
int temp = 0;

for (i = 0; i < n; i++){
  for (j = i+1; j < n; j++) { 
       if(array[i] > array[j]) {    
               temp = array[i];    
               array[i] = array[j];    
               array[j] = temp;
    }     
  }     
}     

quartile = n / 4;

//Fazer teste para quando for preciso arredondar o número para i inteiro superior

printf ("\nThe position of the Q1 is: person[%d].a1\n", quartile);

return quartile;

}

int Find_3Quartile(double array[] , int n) {
    int quartile_3 = 0;
//Sort the elements of the array in ascending order:

int i = 0;
int j = 0;
int temp = 0;

for (i = 0; i < n; i++){
  for (j = i+1; j < n; j++) { 
       if(array[i] > array[j]) {    
               temp = array[i];    
               array[i] = array[j];    
               array[j] = temp;
    }     
  }     
}     

quartile_3 = (n * 3) / 4;

//Fazer teste para quando for preciso arredondar o número para i inteiro superior

printf ("\nThe position of the Q3 is: person[%d].a1\n", quartile_3);


return quartile_3;

}

void how_soon_is_now () {

 time_t rawtime;
    struct tm * timeinfo;

    time (&rawtime);
    timeinfo = localtime ( &rawtime );
    printf ( "%s", asctime (timeinfo));

}
